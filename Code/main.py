'''
This file is the main file that follows the paper "Multiple Nuclei 
Tracking Using Integer Programming for Quantitative Cancer Cell C-
ycle Analysis". The proposed algorithm mainly contains two parts: 
Nuclei Segmentation and Nuclei Tracking. 

Nuclei Segmentation:
It includes three steps:
1. Binarization - using adaptive thresholding - adaptivethresh.py
2. Nuclei center detection - using gradient vector feild (GVF) - gvf.py
3. Nuclei boundary delinating - using watershed algorithm - watershed.py

Nuclei Tracking:
It includes three steps:
1. Neighboring Graph Constrction
2. Optimal MatchingRAY
3. Cell Division, Death, Segmentation Errors Detection& Processing

'''
import cv2
import sys
import os
import numpy as np
import imageio
from adaptivethresh import ADPTIVETHRESH as athresh
from gvf import GVF
from matplotlib import pyplot as plt
from watershed import WATERSHED as WS
from graph_construction import GRAPH
from matching import FEAVECTOR as FEA
from matching import SIMPLE_MATCH as MAT
import render
from PIL import Image
def set_date(vectors):
	'''
	This function is to add the start and end frame of each vector and
	combine the vector with same id.

	Input: the list of vectors in different frames.

	Output: the list of vectors of all cell with different id.

	'''
	max_id = 0
	for vector in vectors:
		for pv in vector:
			if pv.id > max_id:
				max_id = pv.id

	max_id = int(max_id)
	output = np.zeros((max_id, 4))
	output[:,0] = np.linspace(1, max_id, max_id) # set the cell ID
	output[:,1] = len(vectors)
	for frame, vector in enumerate(vectors):
		for pv in vector:
			if output[int(pv.id)-1][1] > frame:     # set the start frame
				output[int(pv.id)-1][1] = frame
			if output[int(pv.id)-1][2] < frame:     # set the end frame
				output[int(pv.id)-1][2] = frame
			output[int(pv.id)-1][3] = int(pv.l)          # set tht cell parent ID

	return output

def write_info(vector, name):
	'''
	This function is to write info. of each vector.

	Input: the list of vector generated by set_date() and
	       the name of output file.

	'''
	with open(name+".txt", "w+") as file:
		for p in vector:
			file.write(str(int(p[0]))+" "+\
				       str(int(p[1]))+" "+\
				       str(int(p[2]))+" "+\
				       str(int(p[3]))+"\n")

def normalize(image):
    '''
    This function is to normalize the input grayscale image by
    substracting globle mean and dividing standard diviation for
    visualization. 

    Input:  a grayscale image

    Output: normolized grascale image

    '''
    img = image.copy().astype(np.float32)
    img -= np.mean(img)
    img /= np.linalg.norm(img)
    # img = (img - img.min() )
    img = np.clip(img, 0, 255)
    img *= (1./float(img.max()))
    return (img*255).astype(np.uint8)

# read image sequence
# The training set locates at "resource/training/01" and "resource/training/02"
# The ground truth of training set locates at "resource/training/GT_01" and 
# "resource/training/GT_02"
# The testing set locates at "resource/testing/01" and "resource/testing/02"


path=os.path.join("/home/huoy1/Projects/celltracking/Fluo-N2DL-HeLa/01")
temporary_result = os.path.join("/home/huoy1/Projects/celltracking/temporary_result_Hela")

for r,d,f in os.walk(path):
    images = []
    enhance_images = []
    f.sort()
    for files in f:
        if files[-3:].lower()=='tif':
            temp = cv2.imread(os.path.join(r,files))
            gray = cv2.cvtColor(temp, cv2.COLOR_BGR2GRAY) 
            images.append(gray.copy())
            enhance_images.append(normalize(gray.copy()))

print "Total number of image is ", len(images)
print "The shape of image is ", images[0].shape, type(images[0][0,0])

def write_image(image, title, index, imgformat='.tiff'):
    if index < 10:
            name = '0'+str(index)
    else:
        name = str(index)
    cv2.imwrite(title+name+imgformat, image)

def load_image(title, index, imgformat='.tiff'):
    if index < 10:
            name = '0'+str(index)
    else:
        name = str(index)
    img_file = title+name+imgformat
    if os.path.exists(img_file):
        img = cv2.imread(title+name+imgformat)
        return img
    else:
        return []

def ws_simple(enhance_images):
    mark = []
    outbinary = []
    for ei in range(len(enhance_images)):
        img = np.zeros((enhance_images[ei].shape[0], enhance_images[ei].shape[1], 3), np.uint8)
        for c in range(3):
            img[:, :, c] = 255 - enhance_images[ei]
        gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
        # ret, thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)
        ret, thresh = cv2.threshold(gray, 250, 255, cv2.THRESH_BINARY_INV)

        # noise removal
        kernel = np.ones((3, 3), np.uint8)
        opening = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, kernel, iterations=2)

        # sure background area
        sure_bg = cv2.dilate(opening, kernel, iterations=3)

        # Finding sure foreground area
        dist_transform = cv2.distanceTransform(opening, cv2.DIST_L2, 5)
        ret, sure_fg = cv2.threshold(dist_transform, 0.2 * dist_transform.max(), 255, 0)

        # Finding unknown region
        sure_fg = np.uint8(sure_fg)
        unknown = cv2.subtract(sure_bg, sure_fg)

        # Marker labelling
        ret, markers = cv2.connectedComponents(sure_fg)

        # # Add one to all labels so that sure background is not 0, but 1
        # markers = markers + 1

        # Now, mark the region of unknown with zero
        markers[unknown == 255] = 0

        markers = cv2.watershed(img, markers)
        u, counts = np.unique(markers, return_counts=True)
        counter = dict(zip(u, counts))
        valid_i = 1
        markers_unique = np.zeros(markers.shape)
        for i in counter:
            if counter[i] > 1200:
                markers_unique[markers == i] = 0
            else:
                markers_unique[markers == i] = valid_i
                valid_i = valid_i+1

        mark.append(markers_unique.astype(np.uint8))

        binary = markers_unique.copy()
        # binary[markers <= 1] = 0
        binary[markers_unique > 0] = 255
        outbinary.append(binary.astype(np.uint8))

    return outbinary, mark

def main():

    use_simple_marker = True

    # Binarization
    if use_simple_marker:
        binarymark, mark = ws_simple(enhance_images)
    else:
        th = athresh(enhance_images)
        threh = th.applythresh()
        write_image(threh[0]*255, "threh", 0)
        # Nuclei center detection
        gvf = GVF(images, threh)
        dismap = gvf.distancemap()
        newimg = gvf.new_image(10, dismap) # choose alpha as 0.4.
        write_image((dismap[0]*10).astype(np.uint8), "dismap", 0)
        write_image(newimg[0], "newimg", 0)
        gradimg = gvf.compute_gvf(newimg)

        if not os.path.exists(temporary_result):
            os.makedirs(temporary_result)
        os.chdir(temporary_result)
        imgpairs = []
        # bin_imgpairs = []
        # imgpair_raws = []
        for i, grad in enumerate(gradimg):
            load_img = load_image('imgpair', i)
            if load_img == []:
                imgpair, bin_imgpair, imgpair_raw = gvf.find_certer(grad, i)
                imgpairs.append(imgpair)
                # bin_imgpairs.append(bin_imgpair)
                # imgpair_raws.append(imgpair_raw)
                # write_image(imgpair_raw, 'imgpair_raw', i)
                # write_image(bin_imgpair, 'bin_imgpair', i)
                write_image(imgpair, 'imgpair', i)
            else:
                imgpair = load_img
                imgpairs.append(imgpair)

        os.chdir(os.pardir)

        # watershed
        ws = WS(newimg, imgpairs)
        wsimage, binarymark, mark = ws.watershed_compute()

    centroid = []
    slope_length = []
    # Build Delaunay Triangulation
    for i in range(len(images)):
        graph = GRAPH(mark, binarymark, i)
        tempcentroid, tempslope_length = graph.run(False) # how many centroid points, and slope and length connect to this point

        centroid.append(tempcentroid)
        slope_length.append(tempslope_length)
        print('building Delaunay Triangulation %d/%d '%(i, len(images)))

    # Build the Dissimilarity measure vector
    vector = []
    for i in range(len(images)):
        print "  feature vector: image ", i
        v = FEA()
        v.set_centroid(centroid[i])
        v.set_spatial(slope_length[i])
        v.set_shape(enhance_images[i], mark[i])
        v.set_histogram()
        v.add_label()
        v.add_id(mark[i].max(), i)
        gen_vec = v.generate_vector()
        vector.append(gen_vec)

        print "num of nuclei: ", len(vector[i])

    # Feature matching
    mask = []

    for i in range(len(images)-1):
        print "  Feature matching: image ", i
        m = MAT(i,i+1,[images[i], images[i+1]], vector)
        mask.append(m.generate_mask(mark[i], i))
        m.find_match(0.3)
        mask = m.match_missing(mask, max_frame=2, max_distance=5)
        vector[i+1] = m.mitosis_refine()
        m.new_id()
        vector[i+1] = m.return_vectors()

    # write gif image showing the final result
    def find_max_id(temp_vector):
        max_id = 0
        for pv in temp_vector:
            for p in pv:
                if p.id > max_id:
                    max_id = p.id
        return max_id

    # This part is to mark the result in the normolized image and
    # write the gif image.
    max_id = find_max_id(vector)
    max_id = int(max_id)
    colors = [np.random.randint(0, 255, size=max_id), \
              np.random.randint(0, 255, size=max_id), \
              np.random.randint(0, 255, size=max_id)]
    font = cv2.FONT_HERSHEY_SIMPLEX
    selecy_id = 9
    enhance_imgs = []
    for i, m in enumerate(mask):
        print "  write the gif image: image ", i
        enhance_imgs.append(cv2.cvtColor(enhance_images[i], cv2.COLOR_GRAY2RGB))
        for pv in vector[i]:
            center = pv.c
            if not pv.l:
                color = (colors[0][int(pv.id) - 1], \
                         colors[1][int(pv.id) - 1], \
                         colors[2][int(pv.id) - 1],)
            else:
                color = (colors[0][int(pv.l) - 1], \
                         colors[1][int(pv.l) - 1], \
                         colors[2][int(pv.l) - 1],)

            if m[int(center[0]), int(center[1])]:
                enhance_imgs[i][m == pv.id] = color
                cv2.putText(enhance_imgs[i], \
                            str(int(pv.id)), (int(pv.c[1]), \
                                              int(pv.c[0])),
                            font, 0.5, \
                            (255, 255, 255), 1)
    os.chdir(temporary_result)
    imageio.mimsave('mitosis_final.gif', enhance_imgs, duration=0.6)

    cells = set_date(vector)
    write_info(cells, "res_track")

    render.plot_tracks(vector)

    print "finish!"

# if python says run, then we should run
if __name__ == '__main__':
    main()